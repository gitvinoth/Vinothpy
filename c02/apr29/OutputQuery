




def generate_sliding_avg_query_for_multi_asset(
    table_name: str,
    avg_prefix_template: str,
    avg_suffix_template: str,
    parameter: str,
    timestamp_column: str,
    asset_id_list: list[str],
    operator: str,
    threshold: float,
    data_frequency_list: list[int],
    join_condition: str = "and",
    duration: int = 10
) -> str:
    """
    Generates a sliding average anomaly detection query for multiple assets.
    """
    try:
        if not asset_id_list or not data_frequency_list or len(asset_id_list) != len(data_frequency_list):
            return "Invalid asset_id_list or data_frequency_list input"

        asset_cte_queries = []
        asset_cte_names = []

        #  Step 1: Shared base CTE
        asset_id_str = ", ".join([f"'{aid}'" for aid in asset_id_list])
        base_cte = f"WITH base_{table_name} AS ( SELECT asset_id, {timestamp_column}, {parameter} FROM `$catalog`.silver_zone.{table_name} WHERE asset_id IN ({asset_id_str}) AND {timestamp_column} BETWEEN $start_time AND $end_time )"

        #  Step 2: Generate CTE per asset
        for idx, (asset_id, data_frequency) in enumerate(zip(asset_id_list, data_frequency_list)):
            cte_name = f"cte_{asset_id.lower()}"
            asset_cte_names.append(cte_name)

            sliding_avg_condition = f"SELECT {timestamp_column} FROM ( SELECT {timestamp_column} FROM base_{table_name} WHERE asset_id = '{asset_id}' ) a JOIN ( SELECT {timestamp_column}, {parameter} FROM base_{table_name} WHERE asset_id = '{asset_id}' ) b ON b.{timestamp_column} BETWEEN a.{timestamp_column} AND a.{timestamp_column} + ({duration} - 1) GROUP BY a.{timestamp_column} HAVING AVG(b.{parameter}) {operator} {threshold}"

            anomaly_grouping = f"{avg_prefix_template.replace('$data_frequency', str(data_frequency))} {sliding_avg_condition} {avg_suffix_template.replace('$data_frequency', str(data_frequency))}"

            asset_cte_queries.append(f"{cte_name} AS ({anomaly_grouping})")

        #  Step 3: Combine all CTEs
        cte_block = base_cte + ", " + ", ".join(asset_cte_queries)

        #  Step 4: Build Join or Union All block
        if join_condition.lower() == "and":
            join_conditions = "\n".join([
                f"INNER JOIN {cte} t{idx+2} ON t1.start_time <= t{idx+2}.end_time AND t{idx+2}.start_time <= t1.end_time"
                for idx, cte in enumerate(asset_cte_names[1:])
            ])
            greatest_fields = ", ".join([f"t{i+1}.start_time" for i in range(len(asset_cte_names))])
            least_fields = ", ".join([f"t{i+1}.end_time" for i in range(len(asset_cte_names))])
            final_query = (
                f"{cte_block} "
                f"SELECT GREATEST({greatest_fields}) AS start_time, LEAST({least_fields}) AS end_time "
                f"FROM {asset_cte_names[0]} t1 "
                f"{join_conditions}"
            )
        else:  # join_condition == "or"
            union_all_assets = " UNION ALL ".join([
                f"SELECT start_time, end_time FROM {cte}" for cte in asset_cte_names
            ])
            final_query = (
                f"{cte_block} "
                f"SELECT start_time, end_time FROM ( {union_all_assets} ) all_anomalies"
            )

        return final_query

    except Exception as e:
        return f"-- Error generating corrected differential query: {str(e)}"
